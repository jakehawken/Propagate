//  StreamPublisher.swift
//  JSync
//  Created by Jake Hawken on 4/5/20.
//  Copyright Â© 2020 Jake Hawken. All rights reserved.

import Foundation

public class Publisher<T, E: Error> {
    
    public typealias State = StreamState<T, E>
    
    fileprivate let lockQueue = DispatchQueue(label: "PublisherLockQueue-\(UUID().uuidString)")
    fileprivate var subscribers = WeakBag<Subscriber<T, E>>()
    private(set) public var isCancelled = false
    
    public init() {
        safePrint("Created new publisher: \(self)", logType: .lifeCycle)
    }
    
    internal func publishNewState(_ state: State) {
        safePrint("Publishing state \(state) from \(self)", logType: .pubSub)
        lockQueue.async {
            guard !self.isCancelled else {
                return
            }
            self.subscribers.forEach { $0.receive(state) }
        }
    }
    
    deinit {
        safePrint("Releasing \(self) from memory.", logType: .lifeCycle)
        // The asynchronous cancelAll() can't be called from deinit
        // because it results in a bad access crash.
        handleCancellation()
    }
    
    public func subscriber() -> Subscriber<T, E> {
        /*
         Any changes made to this function's implementation will
         also need to be made to the same method on StatefulPublisher.
         */
        let canceller = Canceller<T,E> { [weak self] in
            self?.removeSubscriber($0)
        }
        let newSub = Subscriber(canceller: canceller)
        lockQueue.async { [weak self] in
            self?.subscribers.insert(newSub)
        }
        safePrint("Generating new subscriber: \(newSub) from \(self)", logType: .lifeCycle)
        return newSub
    }
    
}

// MARK: debugging

extension Publisher: CustomStringConvertible {
    
    public var description: String {
        return "Publisher<\(T.self),\(E.self)>(\(memoryAddressStringFor(self)))"
    }
    
}

// MARK: - Main interface

public extension Publisher {
    
    func publish(_ model: T) {
        publishNewState(.data(model))
    }
    
    func publish(_ error: E) {
        publishNewState(.error(error))
    }
    
    func publishState(forResult result: Result<T,E>) {
        switch result {
        case .success(let value):
            publish(value)
        case .failure(let error):
            publish(error)
        }
    }
    
    func cancelAll() {
        lockQueue.async {
            self.handleCancellation()
        }
    }
    
}

// MARK: - private / helpers

private extension Publisher {
    
    func removeSubscriber(_ subscriber: Subscriber<T,E>) {
        safePrint("Removing \(subscriber) from \(self)", logType: .pubSub)
        self.subscribers.pruneIf { $0 === subscriber }
    }
    
    func handleCancellation() {
        if isCancelled {
            return
        }
        isCancelled = true
        let removedSubscribers = subscribers.removeAll()
        safePrint("Removing subscribers: \(removedSubscribers)", logType: .pubSub)
        removedSubscribers.forEach {
            safePrint("Sending cancellation signal to \($0)", logType: .pubSub)
            $0.receive(.cancelled)
        }
    }
    
}

// MARK: - Supporting Types

class Canceller<T, E: Error> {
    
    private var cancelAction: ((Subscriber<T,E>) -> Void)?
    
    init(cancelAction: @escaping (Subscriber<T,E>) -> Void) {
        self.cancelAction = cancelAction
    }
    
    internal func cancel(for subscriber: Subscriber<T,E>) {
        guard let action = cancelAction else {
            return
        }
        cancelAction = nil
        action(subscriber)
    }
    
}

// MARK: - StatefulPublisher -

/// A publisher which constantly maintains the last state received.
/// Subscribers generated by this publisher emit synchronously when
/// subscribed to, if a previous state exists, and then behave as
/// normal afterward.
public class StatefulPublisher<T,E: Error>: Publisher<T, E> {

    private var _lastState: State?
    /// The last state received, if any.
    public private(set) var lastState: State? {
        get {
            return _lastState
        }
        set {
            if let value = newValue {
                _lastState = value
            }
        }
    }
    
    private var _lastValue: T?
    public private(set) var lastValue: T? {
        get {
            return _lastValue
        }
        set {
            if let value = newValue {
                _lastValue = value
            }
        }
    }
    
    public override init() {
        super.init()
    }
    
    override func publishNewState(_ state: State) {
        lastState = state
        lastValue = state.value //Computed property ignores nil, so this is ok.
        super.publishNewState(state)
    }
    
    public override func subscriber() -> Subscriber<T, E> {
        /*
         Any changes made to this function's implementation will
         also need to be made to the same method on Publisher.
         */
        let canceller = Canceller<T,E> { [weak self] in
            self?.removeSubscriber($0)
        }
        
        // These two lines should be the only difference between this and the super.
        let newSub = OnSubscribeCallbackSubscriber(canceller: canceller)
        newSub.lastStateCallback = { [weak self] in self?.lastState }
        
        lockQueue.async { [weak self] in
            self?.subscribers.insert(newSub)
        }
        safePrint("Generating new subscriber: \(newSub) from \(self)", logType: .lifeCycle)
        return newSub
    }
    
}
